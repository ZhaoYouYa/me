---
tags:
    - Design Pattern
---

::: info Introduction

行为模式负责对象间的高效沟通和职责委派

:::

## Chain of Responsibility  责任链模式

> 允许你将请求沿着处理者链进行发送。收到请求后，每个处理者均可对请求进行处理，或将其传递给链上的下个处理者。

```plantuml
class Client
note bottom of Client: h1 = new HandleA()\nh2 = new HandleB()\nh3 = new HandleC()\nh1.setNext(h2)\nh2.setNext(h3)\n//...\nh1.handleRequest()

interface Handler {
    + setNext(Handler handler)
    + handle(request)
}

class BaseHandler {
    - next:Handler
    --
    + setNext(Handler handler)
    + handle(request)
}
note bottom of BaseHandler: handle(request) { \n    if (next != null) \n        next.handle(request) \n    else \n        // do something \n    } \n}
class ConcreteHandlers {
    ...
    --
    + handle(request)
}
note bottom of ConcreteHandlers: if(canHandle(request)) \n    handle(request) \nelse \n    next.handle(request)

Client --> Handler
Handler <|.. BaseHandler
Handler <|-- ConcreteHandlers
BaseHandler o--> Handler
```

- 处理者(Handler)：声明了所有具体处理者的通用接口。该接口通常仅包含单个方法用于请求处理，但有时其还会包含一个设置链上下各处理者的方法
- 基础处理者(BaseHandler)：是一个可选的类，你可以将所有处理者共用的样本代码放置在其中
- 具体处理者(ConcreteHandlers)：包含处理请求的实际代码。每个处理者接收到请求后，都必须决定是否进行处理，以及是否沿着链传递请求。
    - 处理者通常是独立且不可变的，通常需要构造函数一次性的获得所有必要的数据
- 客户端(Client)：可根据程序逻辑一次性或动态地生成链。请求可以发送给链上的任意一个处理者，而非必须是第一个处理者

### 适用场景

- 当程序需要使用不同方式处理不同种类请求，而且请求类型和顺序都预先未知时，可以使用责任链模式
- 当必须按顺序执行多个处理者时，可以使用该模式
- 如果所需处理者及其顺序必须在运行时进行改变，可以使用责任链模式

### 优缺点

√ 你可以控制请求处理的顺序。

√ 单一职责原则。你可对发起操作和执行操作的类进行解耦

√ 开闭原则。你可以在不更改现有代码的情况下在程序中新增处理者

× 部分请求可能未被处理

### 与其他模式的关系


## Command  命令模式

> 它可将请求转换为一个包含请求相关的所有信息的独立对象。该转换让你能够根据不同的请求将方法参数化、延迟请求执行或将其放入队列中，且能实现可撤销操作。

```plantuml
class Client

class Invoker {
    - command
    --
    + setCommand(Command command)
    + execute()
}
note bottom of Invoker: cmd = new Command1()//from other\ninvoker.setCommand(cmd)\n
interface Command {
    + execute()
}

class Command1 {
    - receiver
    - params
    --
    + execute()
    + Command1(receiver, params)
}
class Command2 {
    + execute()
}

class Receiver {
    ...
    --
    + operation(a,b,c)
}

Client --> Invoker
Invoker --> Command
Command <|.. Command1
Command <|.. Command2

Command1 --> Receiver: receiver.operation(params)
Client --> Receiver
```

- 触发者(Invoker)：类负责对请求秦星初始化，其中必须包含一个成员变量来存储对于命令对象的引用。Invoker 触发命令，而不向接收者直接发送请求
    - 发送者并不复杂创建对象：它通常会通过构造函数从客户端出获得预先生成的命令

- 命令(Command)：接口通常仅声明一个执行命令的方法

- 具体命令(ConcreteCommands)：会实现各种类型的请求。具体命令自身并不完成工作，而是会将调用委派给一个业务逻辑对象
    - 接收对象执行方法所需的参数可以声明为具体命令的成员变量
- 接收者(Receiver)：类包含部分业务逻辑。几乎所有对象都可以作为接收者。绝大部分命令只处理如何将请求传递到接收者的细节，接收者会自己完成实际的工作。
- 客户端(Client)：会创建并配置具体命令对象。客户端必须将包括接收者实体在内的所有请求参数传递给命令的构造函数。此后，生成的命令就可以与一个或多个发送者相关联了。

### 适用场景

- 如果你需要通过操作来参数化对象，可以使用命令模式。
  - 命令模式可将特定的方法调用转化为独立对象，因此可以保存、传递
- 如果你想要将操作放入到队列中，操作的执行或者远程执行操作，可使用命令模式
- 如果你想实现操作回滚功能，可使用命令模式

### 优缺点

√ 单一职责原则。你可以解耦触发和执行操作的类。

√ 开闭原则。你可以在不更改现有代码的情况下在程序中新增命令

√ 你可以实现撤销和恢复功能

√ 你可以实现操作的延迟执行

√ 你可以将一组简单命令组合成一个复杂命令

× 代码可能会变得复杂，因为你在发送者和接收者之间增加了一个全新的层次

### 与其他模式的关系

## Iterator 迭代器模式

> 让你能在不暴露集合底层表现形式(列表、栈、树等)的情况下遍历集合中所有的元素

迭代器模式的主要思想是将集合的遍历行为抽取为单独的迭代器对象。

```plantuml
class Client 
interface Iterator {
    + getNext()
    + hasMore(): boolean
}
interface IterableCollection {
    + createIterator(): Iterator
}
class ConcreteIterator {
    - collection:ConcreteCollection
    - iterationState
    --
    + getNext()
    + hasMore(): boolean
    + ConcreteIterator(collection)
}
class ConcreteCollection {
    ...
    --
    ...
    + createIterator(): Iterator
}
Client --> Iterator
Client --> IterableCollection
Iterator <|.. ConcreteIterator
IterableCollection <|.. ConcreteCollection
ConcreteCollection <--> ConcreteIterator
IterableCollection ..> Iterator
```

- 迭代器(Iterator)：接口声明了用于遍历集合中元素的操作：获取下一个元素、获取当前位置和重新开始迭代等

- 具体迭代器(ConcreteIterator)：实现遍历集合的一种特定算法。迭代器对象必须跟踪自身遍历的进度。这使得多个迭代器可以相互独立的遍历同一个集合
- 集合(Collection)：接口声明了一个或多个方法获取与集合兼容的迭代器。注意：返回方法的类型必须被声明为迭代器接口，因此具体集合可以返回各种不同种类的迭代器
- 具体集合(ConcreteCollection)：会在客户端请求迭代器时返回一个特定的具体迭代器类实体。集合返回与其相关的具体迭代器
- 客户端(Client)：通过集合和迭代器的接口与两者进行交互。这样一来客户端无需与具体类进行耦合，允许同一客户端代码使用不同的集合和迭代器
    - 客户端通常不会自行创建迭代器，而是会从集合中获取。但在特定情况下。客户端可以直接创建一个迭代器。

### 适用场景

- 当集合背后为复杂的数据结构，且你希望对客户端隐藏其复杂性(出于安全或者便利性的考虑)时，可使用迭代器模式

- 使用该模式可以减少程序中重复的遍历代码

- 如果你希望代码能够遍历不同的甚至是无法预知的数据结构，可以使用迭代器模式

### 优缺点

√ 单一职责原则。 通过将体积庞大的遍历算法代码抽取为独立的类，你可对客户端代码和集合进行整理

√ 开闭原则。你可实现新型的集合和迭代器并将其传递给现有代码，无需修改现有代码。

√ 你可以并行遍历同一集合，因为每个迭代器对象都包含其自身的遍历状态。

√ 相似的，你可以暂停遍历并在需要时继续。

× 如果你的程序只与简单的集合进行交互，应用该模式可能矫枉过正

× 对于某些特殊集合，使用迭代器可能比直接遍历的效率低

### 与其他模式的关系