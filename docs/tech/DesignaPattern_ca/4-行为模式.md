---
tags:
    - Design Pattern
---

::: info Introduction

行为模式负责对象间的高效沟通和职责委派

:::

## Chain of Responsibility  责任链模式

> 允许你将请求沿着处理者链进行发送。收到请求后，每个处理者均可对请求进行处理，或将其传递给链上的下个处理者。

```plantuml
class Client
note bottom of Client: h1 = new HandleA()\nh2 = new HandleB()\nh3 = new HandleC()\nh1.setNext(h2)\nh2.setNext(h3)\n//...\nh1.handleRequest()

interface Handler {
    + setNext(Handler handler)
    + handle(request)
}

class BaseHandler {
    - next:Handler
    --
    + setNext(Handler handler)
    + handle(request)
}
note bottom of BaseHandler: handle(request) { \n    if (next != null) \n        next.handle(request) \n    else \n        // do something \n    } \n}
class ConcreteHandlers {
    ...
    --
    + handle(request)
}
note bottom of ConcreteHandlers: if(canHandle(request)) \n    handle(request) \nelse \n    next.handle(request)

Client --> Handler
Handler <|.. BaseHandler
Handler <|-- ConcreteHandlers
BaseHandler o--> Handler
```

- 处理者(Handler)：声明了所有具体处理者的通用接口。该接口通常仅包含单个方法用于请求处理，但有时其还会包含一个设置链上下各处理者的方法
- 基础处理者(BaseHandler)：是一个可选的类，你可以将所有处理者共用的样本代码放置在其中
- 具体处理者(ConcreteHandlers)：包含处理请求的实际代码。每个处理者接收到请求后，都必须决定是否进行处理，以及是否沿着链传递请求。
    - 处理者通常是独立且不可变的，通常需要构造函数一次性的获得所有必要的数据
- 客户端(Client)：可根据程序逻辑一次性或动态地生成链。请求可以发送给链上的任意一个处理者，而非必须是第一个处理者

### 适用场景

- 当程序需要使用不同方式处理不同种类请求，而且请求类型和顺序都预先未知时，可以使用责任链模式
- 当必须按顺序执行多个处理者时，可以使用该模式
- 如果所需处理者及其顺序必须在运行时进行改变，可以使用责任链模式

### 优缺点

√ 你可以控制请求处理的顺序。

√ 单一职责原则。你可对发起操作和执行操作的类进行解耦

√ 开闭原则。你可以在不更改现有代码的情况下在程序中新增处理者

× 部分请求可能未被处理

### 与其他模式的关系


## Command  命令模式

> 它可将请求转换为一个包含请求相关的所有信息的独立对象。该转换让你能够根据不同的请求将方法参数化、延迟请求执行或将其放入队列中，且能实现可撤销操作。

```plantuml
class Client

class Invoker {
    - command
    --
    + setCommand(Command command)
    + execute()
}
note bottom of Invoker: cmd = new Command1()//from other\ninvoker.setCommand(cmd)\n
interface Command {
    + execute()
}

class Command1 {
    - receiver
    - params
    --
    + execute()
    + Command1(receiver, params)
}
class Command2 {
    + execute()
}

class Receiver {
    ...
    --
    + operation(a,b,c)
}

Client --> Invoker
Invoker --> Command
Command <|.. Command1
Command <|.. Command2

Command1 --> Receiver: receiver.operation(params)
Client --> Receiver
```

- 触发者(Invoker)：类负责对请求秦星初始化，其中必须包含一个成员变量来存储对于命令对象的引用。Invoker 触发命令，而不向接收者直接发送请求
    - 发送者并不复杂创建对象：它通常会通过构造函数从客户端出获得预先生成的命令

- 命令(Command)：接口通常仅声明一个执行命令的方法

- 具体命令(ConcreteCommands)：会实现各种类型的请求。具体命令自身并不完成工作，而是会将调用委派给一个业务逻辑对象
    - 接收对象执行方法所需的参数可以声明为具体命令的成员变量
- 接收者(Receiver)：类包含部分业务逻辑。几乎所有对象都可以作为接收者。绝大部分命令只处理如何将请求传递到接收者的细节，接收者会自己完成实际的工作。
- 客户端(Client)：会创建并配置具体命令对象。客户端必须将包括接收者实体在内的所有请求参数传递给命令的构造函数。此后，生成的命令就可以与一个或多个发送者相关联了。

### 适用场景

- 如果你需要通过操作来参数化对象，可以使用命令模式。
  - 命令模式可将特定的方法调用转化为独立对象，因此可以保存、传递
- 如果你想要将操作放入到队列中，操作的执行或者远程执行操作，可使用命令模式
- 如果你想实现操作回滚功能，可使用命令模式

### 优缺点

√ 单一职责原则。你可以解耦触发和执行操作的类。

√ 开闭原则。你可以在不更改现有代码的情况下在程序中新增命令

√ 你可以实现撤销和恢复功能

√ 你可以实现操作的延迟执行

√ 你可以将一组简单命令组合成一个复杂命令

× 代码可能会变得复杂，因为你在发送者和接收者之间增加了一个全新的层次

### 与其他模式的关系

## Iterator 迭代器模式

> 让你能在不暴露集合底层表现形式(列表、栈、树等)的情况下遍历集合中所有的元素

迭代器模式的主要思想是将集合的遍历行为抽取为单独的迭代器对象。

```plantuml
class Client 
interface Iterator {
    + getNext()
    + hasMore(): boolean
}
interface IterableCollection {
    + createIterator(): Iterator
}
class ConcreteIterator {
    - collection:ConcreteCollection
    - iterationState
    --
    + getNext()
    + hasMore(): boolean
    + ConcreteIterator(collection)
}
class ConcreteCollection {
    ...
    --
    ...
    + createIterator(): Iterator
}
Client --> Iterator
Client --> IterableCollection
Iterator <|.. ConcreteIterator
IterableCollection <|.. ConcreteCollection
ConcreteCollection <--> ConcreteIterator
IterableCollection ..> Iterator
```

- 迭代器(Iterator)：接口声明了用于遍历集合中元素的操作：获取下一个元素、获取当前位置和重新开始迭代等

- 具体迭代器(ConcreteIterator)：实现遍历集合的一种特定算法。迭代器对象必须跟踪自身遍历的进度。这使得多个迭代器可以相互独立的遍历同一个集合
- 集合(Collection)：接口声明了一个或多个方法获取与集合兼容的迭代器。注意：返回方法的类型必须被声明为迭代器接口，因此具体集合可以返回各种不同种类的迭代器
- 具体集合(ConcreteCollection)：会在客户端请求迭代器时返回一个特定的具体迭代器类实体。集合返回与其相关的具体迭代器
- 客户端(Client)：通过集合和迭代器的接口与两者进行交互。这样一来客户端无需与具体类进行耦合，允许同一客户端代码使用不同的集合和迭代器
    - 客户端通常不会自行创建迭代器，而是会从集合中获取。但在特定情况下。客户端可以直接创建一个迭代器。

### 适用场景

- 当集合背后为复杂的数据结构，且你希望对客户端隐藏其复杂性(出于安全或者便利性的考虑)时，可使用迭代器模式

- 使用该模式可以减少程序中重复的遍历代码

- 如果你希望代码能够遍历不同的甚至是无法预知的数据结构，可以使用迭代器模式

### 优缺点

√ 单一职责原则。 通过将体积庞大的遍历算法代码抽取为独立的类，你可对客户端代码和集合进行整理

√ 开闭原则。你可实现新型的集合和迭代器并将其传递给现有代码，无需修改现有代码。

√ 你可以并行遍历同一集合，因为每个迭代器对象都包含其自身的遍历状态。

√ 相似的，你可以暂停遍历并在需要时继续。

× 如果你的程序只与简单的集合进行交互，应用该模式可能矫枉过正

× 对于某些特殊集合，使用迭代器可能比直接遍历的效率低

### 与其他模式的关系

## Mediator 中介者模式

> 能让你减少对象之间的混乱无序的依赖关系，该模式会限制对象之间的直接交互，迫使它们通过一个中介者对象交互

类所拥有的依赖关系越少，就越易于修改、扩展、和复用。

```plantuml
interface Mediator {
    + notify(sender)
}
class ConcreteMediator {
    - componentA
    - componentB
    - componentC
    - componentD
    --
    + notify(sender)
    + reactOnA()
    + reactOnB()
    + reactOnC()
    + reactOnD()
}
note right of ConcreteMediator: if(sender == componentA)\n  reactOnA()

class componentA {
    -m: Mediator
    --
    + operationA()
}
note bottom of componentA: m.notify(this)
class componentB {
    -m: Mediator
    --
    + operationB()
}
class componentC {
    -m: Mediator
    --
    + operationC()
}
class componentD {
    -m: Mediator
    --
    + operationD()
}
Mediator <|.. ConcreteMediator
componentA --> Mediator
componentB --> Mediator
componentC --> Mediator
componentD --> Mediator

ConcreteMediator *-- componentA
ConcreteMediator *-- componentB
ConcreteMediator *-- componentC
ConcreteMediator *-- componentD
```

- 组件(Component)：是各种包含业务逻辑的类，每个组件都有一个指向中介者的引用，该引用被声明为中介者接口类型。组件不知道中介者实际所属的类，因此你可以通过将其连接到不同的中介者以使能在其他程序中复用

- 中介者(Mediator)：接口声明了与组件交流的方法，但通常仅包括一个通知方法。组件可将任意上下文(内容？)(包括自己的对象)作为该方法的参数，只有这样接收组件和发送者类之间才不会耦合

- 具体中介者(ConcreteMediator)：封装了多种组件间的关系。具体中介者通常会保存所有组件的引用并对其进行管理，甚至有时会对其生命周期进行管理

- 组件并不知道其它组件的情况。如果组件内发生了重要事件，它只能通知中介者。中介者收到通知后能轻易地确定发送者，这或许足以判断接下来需要触发的组件了。
   - 对于组件来说，中介者完全就是一个黑箱。发送者不知道最终会由谁来处理自己的请求，接收者也不知道最初是谁发出了请求

 ### 适用场景

- 当一些对象和其他对象紧密耦合以致难以对其进行修改时，可使用中介者模式
    - 该模式将对象间的所有关系抽取成为一个单独的类，以使对于特定组件的修改工作独立于其他组件
- 当组件因过于依赖其他组件而无法在不同应用中复用时，可以使用中介者模式
    - 应用中介者模式，每个组件不在知晓其他组件的情况。这些组件无法直接交流，但它们可以通过中介者对象交流。如果你希望在不同应用中复用一个组件，则需要为其提供一个新的中介者类
- 如果为了能在不同情境下复用一些基本行为，导致你需要被迫创建大量组件之类时，可使用中介者模式
    - 由于所有组件间关系都被包含在中介者中，因此你无需修改组件就能方便的新建中介者类以定义新的组件合作方式

### 优缺点

√ 单一职责原则。你可以将多个组件间的交流抽取到同一位置，使其更易于理解和维护

√ 开闭原则。你无需修改实际组件就能增加新的中介者。

√ 你可以减轻应用中多个组件间的耦合情况

√ 你可以更方便的复用各个组件

× 中介者可能演化成一个上帝对象(一个超级大的类)

### 与其他模式的关系

## Memento 备忘录模式

> 允许在不暴露对象实现细节的情况下保存和恢复对象之前的状态

```plantuml

class Originator {
    -state
    --
    + save() : Memento
    + restore(m:memento)
}
class Memento {
    - state
    - Memento(state)
    - getState()
}
class Caretaker {
    - originator
    - history: Memento[]
    --
    + doSomething()
    + undo()
}
note bottom of Caretaker : m = history.pop()\n originator.restore(m)
note bottom of Caretaker : m = originator.save()\n history.push(m)

Originator *-- Memento
Caretaker *-- Memento
```
- 原发器(Originator)：类可以生成自身状态的快照，也可以在需要时通过快照恢复自身状态
- 备忘录(Memento)：是原发器状态快照的值对象。通常做法是将备忘录设为不可变的，并通过构造函数一次性传递数据
- 负责人(Caretaker)：仅知道何时和为何捕捉原发器的状态，以及何时恢复状态

**封装更加严格的实现：**

```plantuml
interface Originator {
    + save() : Memento
}
interface Memento {
    + restore()
}
class CareTaker {
    - history: Memento[]
    --
    + undo()
}
class ConcreteOriginator {
    - state
    --
    + save() : Memento
    + setState(state)
}

class ConcreteMemento {
    - state
    - originator
    --
    + ConcreteMemento(state,originator)
    + restore()
}
note bottom of CareTaker : originator.setState(state)

Originator <|.. ConcreteOriginator
Memento <|.. ConcreteMemento
CareTaker *--> Memento
ConcreteOriginator <--> ConcreteMemento
```

- 这种实现方式允许存在多种不同类型的原发器和备忘录。每种原发器都和其相应的备忘录类进行交互。原发器和备忘录都不会将其状态暴露给其它类

- 负责人此时被明确禁止修改存储子啊备忘录中的状态。但负责人类将独立于原发器，因此此时恢复方法被定义在了备忘录类中

- 每个备忘录将于创建了自身的原发连接，原发器会将自己及状态传递给备忘录的构造函数。由于这些类之间的紧密联系，只要原发器定义了合适的设置器(setter)，备忘录能恢复其状态。

### 适用场景

- 当你需要创建对象状态快照来恢复其之前的状态时，可以使用备忘录模式
  - 备忘录模式允许你复制对象中的全部状态，包括私有成员变量，并将其独立于对象进行保存。

- 当直接访问对象的成员变量、获取器或设置器将导致封装被突破时，可以使用备忘录模式
    - 也就是你不要直接访问我的变量，我copy 一份给你

### 优缺点

√ 你可以在不破坏封装性的前提下创建对象状态快照

√ 你可以通过让负责人维护原发器状态历史记录来简化原发器代码

× 如果频繁的创建备忘录，程序将消耗大量的内存

× 负责人必须完整跟踪原发器的生命周期，这样才能销毁弃用的备忘录

### 与其他模式的关系