---
tags:
    - Design Pattern
---

::: info Introduction
结构型模式介绍如何将对象和类组装成较大的结构，并同时保持结构的灵活和高效。
:::

## Adapter 适配器模式

> Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。

```plantuml
allowmixing
component Client 
interface ClientInterface {
    + method(data)
}
class Adapter {
    - adaptee: Service
    + method(data)
}
class Service {
    ...
    --
    + serviceMethod(specialData)
}
Client -->ClientInterface
Adapter ..|> ClientInterface
Adapter --> Service
note bottom of Adapter: specialData = convertToServiceFormat(data)\nreturn adaptee.serviceMethod(specialData)
```

- 客户端(Client) 包含当前程序业务逻辑的类
- 客户端接口(ClientInterface) 描述了其它类与客户端代码合作时必须遵循的协议
- 适配器(Adapter) 是一个可以同时与客户端和服务交互的类： 它在实现客户端接口的同时封装了服务对象。适配器接受客户端通过适配器接口发起的调用，并将其转换为适用于被封装服务对象的调用。
- 服务(Service) 中有一些功能类(通常来自于第三方或遗留系统)。客户端与其接口不兼容，因此无法直接调用其功能。

### 适用场景

- 当你使用某个类，但是其接口与其它代码不兼容时，可以使用适配器模式。

### 优缺点

√ 单一职责原则，你可以将接口或数据转换代码从程序主要业务逻辑中分离
√ 开闭原则。 只要客户端代码通过客户端接口与适配器进行交互，你就可以在不修改现有客户端代码的情况下在程序中添加新类型的适配器。
× 代码整体复杂度增加，因为需要引入一个额外的间接层。

### 与其它模式的关系

## Bridge 桥接模式

> 可将一个大类或一系列紧密相关的类拆分为抽象和实现两个独立的层次结构，从而能在开发时分别使用。

```plantuml
class Client
note right of Client: abstraction.feature1()
class Abstract {
    - i: Implementation
    --
    + feature1()
    + feature2()
}
note left of Abstract: i.method1()\ni.method2()\ni.method3()
interface Implementation { 
    + method1()
    + method2()
    + method3()
}
class RefinedAbstract {
..
--
+ featureN()
}
note left of RefinedAbstract: i.methodN()
class ConcreteImplementations 

Client --> Abstract
Abstract <|-- RefinedAbstract:可选
Abstract #--> Implementation
ConcreteImplementations ..|> Implementation

```
- 抽象(Abstract) 提供高层逻辑控制，依赖于完成底层实际工作的实现对象，注意：这里 Abstract 不是指抽象类，他是独立于平台的实现，类似于llvm ir code 或者 汇编代码
- 实现部分(Implementation) 为所有具体实现声明通用接口，抽象部分仅能通过在这里声明的方法与实现对象交互
- 具体实现(ConcreteImplementations) 中包含特定于平台的代码
- 精确抽象(RefinedAbstract) 提供控制逻辑的变体。与其父类一样，他们通过通用实现接口与不同的实现进行交互。
- 客户端(Client) 通常情况下，仅关心如何与抽象部分合作，但是客户端需要将抽象对象与一个实现对象连接起来。

### 适用场景

- 如果你想要拆分或重组一个具有多重功能的庞杂类(例如能与多个数据库服务器进行交互的类)
    - 类的代码行数越多，弄清其运作方式就越困难，一个功能上的变化可能需要在整个类范围内进行修改，而且常常会产生错误
    - 桥接模式可以将庞杂类拆分为一个类层次机构。此后，你可以修改任意一个层次结构而不会影响到其它类层次结构。这种方法可以简化代码的维护工作，并将修改已有代码的风格降到最低。

- 如果你希望在几个独立维度上扩展一个类，可使用该模式
    - 桥接建议将每个维度抽取为独立的类层次。初始类将相关工作委派给属于对应类层次的对象，无需自己完成所有工作。
- 如果你需要在运行时切换不同的实现方法，可以使用桥接模式
    - 桥接模式可以替换抽象部分中的实现部分。

### 优缺点

√ 你可以创建与平台无关的类和程序
√ 客户端代码仅与高层抽象部分进行互动，不会接触到平台的详细信息。
√ 开闭原则。你可以新增抽象部分和实现部分，它们之间不会相互影响
√ 单一职责原则。抽象部分专注于处理高层逻辑，实现部分专注于处理平台细节。
× 对高内聚的类使用该模式可能会让代码更加复杂

### 与其它模式的关系


## Composite 组合模式

> 你可以使用它将对象组合成树状结构，并且能像使用独立对象一样使用他们。

```plantuml
class Client

interface Component {
    + execute()
}
class Leaf {
    ...
    --
    + execute()
}
note bottom of Leaf: 完成一些工作
class Composite {
    - children: Component[]
    --
    + execute()
    + add(Component)
    + remove(Component)
    + getChildren():Component[]
    + execute()
}
note bottom of Composite: 将所有工作委派给子元素

Client --> Component
Component <|.. Leaf
Component <|.. Composite
Composite *-- Component

```
- 组件(Component) 接口描述了树中简单项目和复杂项目所共有的操作
- 叶子节点(Leaf) 是树的基本结构，它不包含子项目
- 容器(Container) 或 组合(Composite) 是包含叶节点或其他容器等子项目的单位。容器不知道其子项目所属的具体类，它只通过通用的组件接口与其子项目交互。
    - 容器接收到请求后会将工作分配给自己的子项目，处理中间结果，然后将最终结果返回给客户端
- 客户端(Client) 通过组件接口与所有项目交互。因此，客户端能以相同方式与树状结构中的简单或复杂项目交互

### 适用场景

- 如果你需要实现树状对象结构，可以使用组合模式
    - 组合模式为你提供了两种共享公共接口的基本元素类型：简单叶节点和复杂容器。容器中可以包含叶节点和其他容器。这使得你可以构建树状嵌套递归对象结构
- 如果你希望客户端代码以相同方式处理简单和复杂元素，可以使用组合模式

### 优缺点

√ 你可以利用多态和递归机制更方便地是同复杂树结构
√ 开闭原则。无需更改现有代码，你就可以在应用中添加新元素，使其成为对象树的一部分。
× 对于功能差异较大的类，提供公共结构或许存在困难。在特定情况下，你需要过度一般化组件接口，使其变得令人难以理解。

### 与其它模式的关系

## Decorator(Wrapper) 装饰模式

> 允许你通过将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为。

```plantuml
class Client
note right of Client: a = new ConcreteComponent()\nb = new ConcreteDecorator1(a)\nc = new ConcreteDecorator2(b)\nc.operation()

interface Component  {
 + execute()   
}
class ConcreteComponent {
    ...
    --
    + execute()
}
abstract BaseDecorator {
    - wrapper: Component
    --
    + BaseDecorator(c:Component)
    + execute()
}
note right of BaseDecorator: wrapper = c\nwrapper.execute()

class ConcreteDecorators extends BaseDecorator {
    ...
    --
    + execute()
    + extra()
}
note right of ConcreteDecorators:super.execute()\nwrapper.extra()

Client --> Component
Component <|.. ConcreteComponent
Component <|.. BaseDecorator
Component <--o BaseDecorator
```
- 组件(Component) 声明封装器和被封装对象的公用接口
- 具体组件(ConcreteComponent) 类是被封装对象所属的类，它定义了基础行为，但装饰类可以改变这些行为
- 基础装饰(BaseDecorator) 类拥有一个指向被封装对象的引用成员变量。该变量的类型应当被声明为通用部件接口，这样它就可以引用具体的部件和装饰。装饰基类会将所有操作委派给被封装的对象。
- 具体装饰(ConcreteDecorator) 定义了可动态添加到组件的额外行为。具体装饰类会重写装饰基类的方法，并再调用父类方法之前或之后进行额外的行为。

- 客户端(Client) 可以使用多层装饰来封装部件，只要它能使用通用接口与所有对象互动即可。

### 适用场景

- 如果你希望在无需修改代码的情况下即可使用对象，且希望在运行时为对象新增额外的行为，可以使用装饰模式
    - 装饰能将业务逻辑组织为层次结构，你可以为各层创建一个装饰，在运行时将各种不同逻辑组合成对象。由于这些对象都遵循通用接口，客户端代码能以相同的方式使用这些对象。
- 如果用继承来扩展对象行为的方案难以实现或者根本不可行，你可以使用该模式

### 优缺点
√ 你无需创建新之类即可扩展对象的行为
√ 你可以在运行时添加或删除对象的功能
√ 你可以用多个装饰封装对象来组合几种行为
√ 单一职责原则。你可以将实现了许多不同行为的一个大类拆分为多个较小的类
× 在封装器栈中删除特定封装器比较困难
× 实现行为不受装饰栈顺序影响的装饰比较困难
× 各层的初始化配置代码看上去可能会很糟糕


