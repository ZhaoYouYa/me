---
tags:
  - 建站
  - web
---

::: info Introduction

建站的过程。网站的内容， 建站的历程，实现的效果，使用哪些工具

:::

## 建站的准备

**基础材料：**

一台云服务器，公网 ip 和一个域名，ssl 证书。

云服务需要购买，域名需要购买。我的云服务器是腾讯云的终身续费同价的 4 核 8G 配置，对于个人网站来说，这个配置显然是富余了。个人网站不会有多少人访问，最低配置的云服务器 1 核 2G 就够用。

终身续费同价还有域名续费劵可用。云服务的费用：一年最高 1200 元左右，因为现在可以领代金劵，所以实际花的钱要少一点，当前是一个月 80 元左右。域名一年几十元。ssl 证书可以使用免费的，亚洲诚信证书一个域名可以申请 20 个证书，也就是 20 年，也有其它地方可以申领免费的 ssl 证书。

**目的：**

[打造个人品牌](/docs/life_ca/实践/行动/打造个人品牌.md)。但主要的原因是：正好有一台云服务器,再买个便宜的域名就可以了

**内容：**

个人网站肯定是仅供交流学习使用。内容需要是可以公开的内容，它不是个人的日记，你要考虑你要展示什么，你给你的浏览者带来什么；主要内容应该是一些事情的结果，不应当有过程的展示。个人网站可以理解为，主动给自己贴一些标签，然后让其它人看到，并认可。这不是朋友圈，也不是微博，是个人可以完全控制的个性化展示，它的内容通常更深度一些，换句话说，你是和合适的人交流，合适的人通常比较少。

## 前端工具

有一堆合适的工具。我选择了 vitepress + naive-ui 的一些组件，一些内容受[vitepress-blog-zaun](https://github.com/clark-cui/vitepress-blog-zaun)启发。

适合个人网站的工具还有:

- hexo
  - 这是成熟的博客框架，有很多主题可以使用。我没有使用它是因为一眼看上去，就感觉它很复杂。成熟同时意味着想改一些东西就可能会麻烦，总有一些地方会不满意。
- 自己从零做
  - 最初的时候，我准备这样做。实际上借助成熟的库例如 markdown-it 等，做主体功能并不麻烦，但是涉及到一些细节的地方，就有非常多的工作量，[我不想深入掌握前端](/todo),所以有轮子用就不要折腾。
- Docusaurus
  - 与 vitepress 对应，react 相关。我不会 react，也不打算学。
- vuepress
  - vitepress 是新一代版本，用 vitepress

如果你想给一个项目提供参考文档，vitepress 开箱即用。但若想用 vitepress 搭建个人网站，通常需要做一些个性化的配置，这种配置是非常简单的。vitepress 可以充分使用 vue。

vitepress 的所有个性化配置都在.vitepress 文件夹下面。关于 vitepress 的使用，你应该有一个 “编译” 的概念，即 vitepress 将 markdown 文件编译成 html，一些元数据，和页面布局在编译期间获得。

### 需求1： 在一些情况下生成系列目录,一些情况不生成

![Alt text](/asserts/sidebar.png)

有时候你写的文章是一系列文章，它应当由多个文章组合成一个目录。vitepress 支持多级目录。现在是想让目录根据一些提示自动生成。

使用 vite-plugin-vitepress-auto-sidebar 插件。在 config.ts 文件中使用插件:

```ts{3,5,8}
//  config.ts
  vite: {
    plugins: [
      // add plugin
      AutoSidebar({
        path: "/",
        collapsed:true,
        sideBarResolved: (data) => {
          let d =filterDocsSideBar(data)
           return d as any
        },
        // You can also set options to adjust sidebar data
        // see option document below
      }),
      htmlImport() as any,
    ],
  }


/**
 * 获取sidebar 目录,当目录下的文件包含'_ca'时，将会在此文件下生成一个sidebar 目录
 * @param {*} item autoside object
 * @returns
 */
export function filterDocsSideBar(item) {
    let beforItems = item['/docs/'][0].items
    let afterItems = {}
    filterDocsSideBarWork(beforItems, afterItems, '/docs/')
    return afterItems
}
function filterDocsSideBarWork(beforItems, willInsertItems, prefix) {
    for (let i = 0; i < beforItems.length; ++i) {
        if (beforItems[i].items) {
            var nprefix = prefix + beforItems[i].text + '/'
            if (beforItems[i].text.includes('_ca')) {
                beforItems[i].text = beforItems[i].text.replace('_ca', '')
                willInsertItems[nprefix] = [beforItems[i]]
            } else {
                filterDocsSideBarWork(beforItems[i].items, willInsertItems, nprefix)
            }
        }
    }

}
```
当你的文件夹目录中有‘_ca’，就会为这个目录下所有的文章生成一个sidebar,当访问此目录下的任意文章时，sidebar就会在界面左边出现，详情可以参考官网和插件的github。


### 需求2： 文章分类排序展示

首先获取文章的元数据，之后对元数据加工，在相应的页面对这些元数据分类排序。

globby等插件可以帮助获取元数据。在展示数据的时候，我使用了naive-ui的一些组件。

**问题：** vitepress 使用ssr，但naive-ui默认不是ssr。我这里让主页数据在客户端渲染。

```html{1}
  <div v-if="notSsrRender">
    <n-config-provider :theme="nTheme">
      <n-space justify="center">
```
'notSsrRender'初始值为 false ,在 onMounted 函数中修改为 true 。ssr时，onMounted不会被执行,这样主页数据就不会在服务端渲染，而是在客户端渲染。假如不这样做，会出现一个服务端渲染结果和客户端不匹配的错误。

**问题：** 代码发布的时候遇到了关于导入naive-ui包的什么commonJs的错误，错误提示让我使用这种方式导入：

```ts
import * as pkg from "naive-ui";
const {
  lightTheme,
  darkTheme,
  NConfigProvider,
  NList,
  NListItem,
  NThing,
  NSpace,
  NTag,
  NTabs,
  NTabPane,
  NScrollbar,
} = pkg;
```

我按照这种方式做了，就没有问题了，因为[我不想深入掌握前端](/todo),这里不再深纠,解决问题就好。

## 后台托管

vitepress 生成的是纯纯静态页面，一个最常用的方式是使用nginx。但是我想用的仅仅就是托管一个静态页面，需要nginx这么庞大的东西吗？nginx性能较高，那是和其它非native语言比的，使用c++ 写个简单的托管静态资源的web server，占用资源极少，性能较高，而且十分简单。

```cpp
#include <drogon/HttpResponse.h>
#include <drogon/HttpTypes.h>
#include <drogon/drogon.h>
#include <drogon/utils/FunctionTraits.h>
#include <functional>
#include <json/value.h>
#include <string>
using namespace drogon;
int main(int argc, char *argv[]) {

  app()
      .setThreadNum(1)
      .registerSyncAdvice([](const HttpRequestPtr &req) -> HttpResponsePtr {
        auto port = req->getLocalAddr().toPort();
        if (port == 80) {
          auto resp = HttpResponse::newRedirectionResponse("https://xxxx.cn");
          return resp;
        } else {
          return nullptr;
        }
      })
      .addListener("0.0.0.0", 443, true,
                   "/home/xxx/.ssl/zerlei.cn_bundle.pem",
                   "/home/xxx/.ssl/zerlei.cn.key")
      .addListener("0.0.0.0", 80)
      .setDocumentRoot("./wwwroot")
      .run();
}

```
使用 `drogon`，这就是全部的代码了。当访问http时，会重定向到https。资源占用十分的让人满意。


## 部署与发布

当写下新的内容时，应当自动发布。首先想到的是git hook。使用腾讯的混元大模型。他是这样回答的:

![Alt text](/asserts/githook1.png)


![Alt text](/asserts/githook2.png)

如果直接把构建的脚本写在post-commit里面，那么每次commit的时候都要等待30-40s用于构建发布，好长时间！若把命名加上 `nohup ...  &`转到后台运行，使用命令行敲commit时没有问题，但使用vscode commit时，还是会等待一段时间。

还有一种方法是创建定时任务，每隔一段时间检查git commit 状态,当有新的commit就发布一次，但这样会失去一定的实时性。

其它还有一些比较沉重的方法就不考虑了。

我想到的一个方案是：在我的静态web server 里写一个接口，实现发布过程；在post-commit写一个 curl 命令，当commit的时候，curl命令会向web server 发一个请求，之后由web server 执行发布的具体步骤，这样做既可以做到，每个commit实时发布，也不会让我在commit的时候等待太长时间。

我实践之后发现存在这样一个问题：

1. web server 开启80 443端口，这需要root权限。
2. 以root权限启动的程序`system()`函数也是默认root用户。
2. 发布工具bun 一般都是在非root用户下使用。

所以，这导致了发布后一些异常错误，页面无法访问，我以为是文件权限问题，但改了文件权限后，还是无法正常访问，所以猜测是在root用户下，执行发布出现了问题，我目前没有想到好的解决办法。

最终，我又写了一个web server , 它使用非root权限运行。所以我现在有两个web server，一个托管静态资源，一个接收commit时的curl请求，执行发布。这种方式十分不优雅，但所幸代价极低，c++写的简易web server 几乎不占用什么资源。不过，话说回来，这符合关注点分离的原则～😬


## 最终的效果

我是在云服务器上写笔记，写代码，当初买了4core 8gb的云服务器也是为此考虑。所以，我写笔记，托管静态服务，都是闭环的在云服务上进行。

用git 托管笔记，每次commit的时候都会执行一次发布，页面的效果就是你看到的样子～
